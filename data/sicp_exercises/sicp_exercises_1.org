
* Exercise 1.1 basics
#+begin_src emacs-lisp

  10
  (+ 5 3 4)
  (- 9 1)
  (/ 6 2)
  (+ (* 2 4) (- 4 6))
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
  (= a b)
  (if (and (> b a) (< b (* a b)))
      b a)

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))

  (+ 2 (if (> b a) b a))

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))

      (+ a 1))

#+end_src

* Exercise 1.2 嵌套
#+begin_src emacs-lisp
 (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
     (* 3 (- 6 2) (- 2 7)))
#+end_src

#+RESULTS:
: 0
 
* Exercise 1.3

Deﬁne a procedure
that takes three numbers as arguments and
returns the sum of the squares of the two
larger numbers.

#+begin_src scheme

(define (sum-of-squares x y)
  (+ (* x x) (* y y)))
(define (>= x y) (not (< x y)))
(define (exe-1.3 x y z)
  [cond ((and (>= x y) (>= y z)) (sum-of-squares x y))
	((and (>= x y) (>= z y)) (sum-of-squares x z))
	((and (>= y x) (>= x z)) (sum-of-squares y x))
	((and (>= y x) (>= z x)) (sum-of-squares y z))
	((and (>= z x) (>= y x)) (sum-of-squares z y))
	((and (>= z x) (>= x y)) (sum-of-squares x z))
	]
  )
  
(>= 3 2)
(exe-1.3 1 2 3)
(exe-1.3 1 2 2)
(exe-1.3 2 2 1)


#+end_src
* Exercise 1.4 操作符也可以cond
#+begin_src
(define (a-plus-abs-b a b)
   ((if (> b 0) + -) a b))

(a-plus-abs-b 1 2)
(a-plus-abs-b 1 -2)

#+end_src
* Exercise 1.5 理解正则序

Ben Bitdiddle has invented a test to determine
whether the interpreter he is faced with is using
applicativeorder evaluation or normal-order
evaluation. He deﬁnes the following two procedures:

#+begin_src scheme
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
#+end_src


(test 0 (p)) 直接死循环了
这里用了app order的话，会先对param求值，(p)本身就是死循环
如果用了正则序，则不会求值，会一直expend，(p)不会被执行，则返回0
https://www.cnblogs.com/ssaylo/p/13633403.html
另外，哪里有答案呐：http://community.schemewiki.org/?SICP-Solutions
随便一下就搜到了

* Exercise 1.6 special form的执行序列问题

#+begin_src scheme :hl_lines 13-15
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))


(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
	(else else-clause)))

;; 这个直接死循环了，区别就是 if 和 new-if
(define (sqrt-iter2 guess x)
  (new-if (good-enough? guess x)
	  guess
	  (sqrt-iter2 (improve guess x) x)))
#+end_src

解释如下：原始的if 是 spcial-form，执行按照应用序处理，
因此只会计算多个参数中的一个，新定义的 new-if是正则序的，
会将所有的param求值，因此会陷入死循环中无法脱出

一个更直观的例子

#+begin_src scheme
 (define (iff <p> <c> <a>) (if <p> <c> <a>))
 (define (tryif a) (if (= a 0) 1 (/ 1 0))) 
 (define (tryiff a) (iff (= a 0) 1 (/ 1 0)))
#+end_src

#+begin_src 
Welcome to DrRacket, version 7.5 [3m].
Language: R5RS; memory limit: 128 MB.
> (tryif 0)
1
> (tryif 1)
. . /: division by zero
> (tryiff 0)
. . /: division by zero
> (tryiff 1)
. . /: division by zero
> 
#+end_src
可以看到，执行到 tryiff 0的时候，也返回了不符合的结果，证明已经执行了param中的内容

* Exercise 1.7 优化goods-enouth

上面的方法，在数字特别小，或者特别大的情况下，执行的不给力，会死循环
比如

#+begin_src
Welcome to Racket v8.4 [cs].
> (sqrt 300000000000000000000000000000000000)
  C-c C-c; user break [,bt for context]
  
#+end_src

这是原来的一系列方法
#+begin_src scheme

(define (square x)
  (* x x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))


(define (sqrt x)
  (sqrt-iter 1.0 x))

#+end_src

#+begin_src scheme
  
(define (square x)
  (* x x))

(define (sqrt-iter guess x)
  (define guess_n (improve guess x))
  (if (good-enough? guess_n guess)
      guess_n
      (sqrt-iter guess_n x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))
(define (good-enough? guess_n guess)
  (< (abs (- guess_n guess)) 0.00001))


(define (sqrt x)
  (sqrt-iter 1.0 x))

#+end_src

改写完成之后，可以发现，执行运算成功了

#+begin_src
> (sqrt 300000000000000000000000000000000000)
547722557505166100.0
> 

#+end_src
